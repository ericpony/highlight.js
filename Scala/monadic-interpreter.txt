def g1(str: String): String = Null
def g2(str: String): String = str
def g3(str: String): String = "[" + str + "]"

// try-catch style nullity handling
try {
  val str = "hello"
  val res = g3(g2(str) + g1(str))
  if(res != null) println(res)
}catch {
  case e : NullPointerException => println("oop!"); // prints oops
}

// monadic nullity handling
def monadify[T](f: T => T) =
  (str: T) => {
    val res = if(str != null) f(str) else str
    if(res != null) Some(res) else None
  }

for {
  x <- "hello"
  y <- monadify(g1)(x)
  z <- monadify(g2)(x)
  r <- monadify(g3)(y + z)
} yield println(r)  // prints None

/* Option monads */

sealed trait Option[T] {
  def map[U](f: T => U): Option[U]
  def flatMap[U](f: T => Option[U]): Option[U]
}
case class Some[T](val t: T) extends Option[T] {
  override def map[U](f: T => U):Option[U] = new Some[U](f(t))
  override def flatMap[U](f: T => Option[U]): Option[U] = f(t)
}
case class None[T] extends Option[T] {
  override def map[U](f: T => U):Option[U] = new None[U]
  override def flatMap[U](f: T => Option[U]):Option[U] = new None[U]
}
case class None[T] extends Option[T] {
  override def map(f: T => U):Option[U] = new None[U]
  override def flatMap(f: T => Option[U]):Option[U] = new None[U]
}

/* A simple evaluator */

type Value = Double
type Env   = M[Option[Value]]

def showM[A](m: M[A]) = "Value: " + m.a + "; Counter: " + m.e(0)

// Monad template
case class M[+A](a: A, e: Env => Env) {
  private def bind(f: A => M[B]): M[B] = {
    val fa = f(a)
    M(fa.a, env => fa.e(e(env)))
  }
  def unitM(a: A) = M(a, env => env)
  def map(f: A => B): M[B] = bind(x => unitM(f(x)))
  def flatMap(f: A => M[B]): M[B] = bind(f)
}

val tickS = M(0, e => e + 1)

def add(a: Env, b: Env): Env =
  for {
    _  <- tickS
    aa <- a
    bb <- b
    c = for {
      a <- aa if aa.nonEmpty
      b <- bb if bb.nonEmpty
    } yield a + b     // yield None if aa is None or bb is None
  } yield c

def div(a: Env, b: Env): Env =
  for {
    _  <- tickS
    aa <- a
    bb <- b
    c = for {
      a <- aa if aa.nonEmpty
      b <- bb if bb.nonEmpty
      b <- Some(b) if b != 0
    } yield a/b     // yield None if b==0 or aa is None or bb is None
  } yield c

val const0 = unitM(Some(0.0))
val const1 = unitM(Some(1.0))
val const2 = unitM(Some(2.0))
val const3 = unitM(Some(3.0))
val expr = div(add(const3, add(const1, const2)), const2)

println(expr)                            // Value: Some(3.0); Counter: 2
println(add(div(expr, const0), const1))  // Value: None; Counter: 5


/* A Interpreter that supports call/cc */

object callccInterpreter {

  case class M[A](f: (A => Answer) => Answer) {
    def bind[B](k: A => M[B])          = M[B](c => f(a => k(a) in c))
    def map[B](f: A => B): M[B]        = bind(x => unitM(f(x)))
    def flatMap[B](f: A => M[B]): M[B] = bind(f)
  }

  type Name   = String
  type Answer = Value

  def id[A](x: A) = x

  def unitM[A](a: A) = M[A](c => c(a))

  def showM(m: M[Value]): String = (m in id).toString()

  def callCC[A](h: (A => M[A]) => M[A]) = M[A](c => h(a => M[A](d => c(a))) in c)

  trait Term
  case class Var(x: Name) extends Term
  case class Con(n: Int) extends Term
  case class Add(l: Term, r: Term) extends Term
  case class Lam(x: Name, body: Term) extends Term
  case class App(fun: Term, arg: Term) extends Term
  case class Ccc(x: Name, t: Term) extends Term

  trait Value
  case object Wrong extends Value {
   override def toString() = "wrong"
  }
  case class Num(n: Int) extends Value {
    override def toString() = n.toString()
  }
  case class Fun(f: Value => M[Value]) extends Value {
    override def toString() = "[function]"
  }

  type Environment = List[Pair[Name, Value]]

  def lookup(x: Name, e: Environment): M[Value] = e match {
    case List()           => unitM(Wrong)
    case Pair(y, b) :: e1 => if (x == y) unitM(b) else lookup(x, e1)
  }

  def add(a: Value, b: Value): M[Value] = Pair(a, b) match {
    case Pair(Num(m), Num(n)) => unitM(Num(m + n))
    case _                    => unitM(Wrong)
  }

  def apply(a: Value, b: Value): M[Value] = a match {
    case Fun(k) => k(b)
    case _      => unitM(Wrong)
  }

  def interp(t: Term, e: Environment): M[Value] = t match {
    case Var(x)    => lookup(x, e)
    case Con(n)    => unitM(Num(n))
    case Add(l, r) => for {
                            a <- interp(l, e)
                            b <- interp(r, e)
                            c <- add(a, b)
                      } yield c
    case App(f, t) => for {
                            a <- interp(f, e)
                            b <- interp(t, e)
                            c <- apply(a, b)
                      } yield c
    case Lam(x, t) => unitM(Fun(a => interp(t, Pair(x, a) :: e)))
    case Ccc(x, t) => callCC(k => interp(t, Pair(x, Fun(k)) :: e))
  }

  def test(t: Term): String = showM(interp(t, List()))

  val term0 = App(Lam("x", Add(Var("x"), Var("x"))), Add(Con(10), Con(11)))
  val term1 = App(Con(1), Con(2))
  val term2 = Add(Con(1), Ccc("k", Add(Con(2), App(Var("k"), Con(4)))))

  def main(args: Array[String]) = {
    println(test(term0))
    println(test(term1))
    println(test(term2))
  }
}
